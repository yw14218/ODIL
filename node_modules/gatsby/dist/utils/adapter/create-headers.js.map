{"version":3,"file":"create-headers.js","names":["normalizePath","input","endsWith","createHeadersMatcher","headers","pathPrefix","stripPathPrefix","path","startsWith","slice","length","dynamicHeaders","staticHeaders","Map","_path","defaultHeaders","header","source","includes","score","rankRoute","push","set","sort","a","b","order","localeCompare","uniqueHeaders","h","key","value","d","match","staticEntry","get","Array","from","entries","map"],"sources":["../../../src/utils/adapter/create-headers.ts"],"sourcesContent":["import { match } from \"@gatsbyjs/reach-router\"\nimport type { IHeader } from \"../../redux/types\"\nimport { rankRoute } from \"../rank-route\"\n\ntype Headers = IHeader[\"headers\"]\ninterface IHeaderWithScore extends IHeader {\n  score: number\n}\n\n// We don't care if the path has a trailing slash or not, but to be able to compare stuff we need to normalize it\nconst normalizePath = (input: string): string =>\n  input.endsWith(`/`) ? input : `${input}/`\n\nexport const createHeadersMatcher = (\n  headers: Array<IHeader> | undefined,\n  pathPrefix: string\n): ((path: string, defaultHeaders: Headers) => Headers) => {\n  function stripPathPrefix(path: string): string {\n    if (pathPrefix && path.startsWith(pathPrefix)) {\n      path = path.slice(pathPrefix.length)\n    }\n\n    return path\n  }\n\n  // Split the incoming user headers into two buckets:\n  // - dynamicHeaders: Headers with dynamic paths (e.g. /* or /:tests)\n  // - staticHeaders: Headers with fully static paths (e.g. /static/)\n  // Also add a score using the rankRoute function to each header\n  let dynamicHeaders: Array<IHeaderWithScore> = []\n  const staticHeaders: Map<string, IHeader> = new Map()\n\n  // If no custom headers are defined by the user in the gatsby-config, we can return only the default headers\n  if (!headers || headers.length === 0) {\n    return (_path: string, defaultHeaders: Headers) => defaultHeaders\n  }\n\n  for (const header of headers) {\n    const source = stripPathPrefix(header.source)\n    if (source.includes(`:`) || source.includes(`*`)) {\n      // rankRoute is the internal function that also \"match\" uses\n      const score = rankRoute(source)\n\n      dynamicHeaders.push({\n        ...header,\n        score,\n        source,\n      })\n    } else {\n      staticHeaders.set(normalizePath(source), {\n        ...header,\n        source,\n      })\n    }\n  }\n\n  // Sort the dynamic headers by score, moving the ones with the highest specificity to the end of the array\n  // If the score is the same, do a lexigraphic comparison of the source\n  dynamicHeaders = dynamicHeaders.sort((a, b) => {\n    const order = a.score - b.score\n    if (order !== 0) {\n      return order\n    }\n    return a.source.localeCompare(b.source)\n  })\n\n  return (path: string, defaultHeaders: Headers): Headers => {\n    path = stripPathPrefix(path)\n\n    // Create a map of headers for the given path\n    // The key will be the header key. Since a key may only appear once in a map, the last header with the same key will win\n    const uniqueHeaders: Map<string, string> = new Map()\n\n    // 1. Add default headers\n    for (const h of defaultHeaders) {\n      uniqueHeaders.set(h.key, h.value)\n    }\n\n    // 2. Add dynamic headers that match the current path\n    for (const d of dynamicHeaders) {\n      if (match(d.source, path)) {\n        for (const h of d.headers) {\n          uniqueHeaders.set(h.key, h.value)\n        }\n      }\n    }\n\n    const staticEntry = staticHeaders.get(normalizePath(path))\n\n    // 3. Add static headers that match the current path\n    if (staticEntry) {\n      for (const h of staticEntry.headers) {\n        uniqueHeaders.set(h.key, h.value)\n      }\n    }\n\n    // Convert the map back to an array of objects\n    return Array.from(uniqueHeaders.entries()).map(([key, value]) => {\n      return {\n        key,\n        value,\n      }\n    })\n  }\n}\n"],"mappings":"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"}