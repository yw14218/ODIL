{"version":3,"file":"entry.js","names":["tracerReadyPromise","initTracer","process","env","GATSBY_OPEN_TRACING_CONFIG_FILE","createHeaders","createHeadersMatcher","INLINED_HEADERS_CONFIG","PATH_PREFIX","isEagerGraphqlEngine","arg","graphqlEngine","getData","getGraphqlEngine","Promise","resolve","pathName","req","spanContext","telemetryResolverTimings","getDataWrapperActivity","reporter","phantomActivity","parentSpan","start","page","templateDetails","potentialPagePath","findMetaActivity","span","getPagePathFromPageDataPath","maybePage","findEnginePageByPath","Error","INLINED_TEMPLATE_TO_DETAILS","componentChunkName","end","executionPromises","results","serverData","query","runningQueryActivity","push","then","runQuery","context","queryName","path","componentPath","forceGraphqlTracing","queryResults","errors","length","e","codeFrame","getCodeFrame","locations","line","column","queryRunningError","message","stack","finally","mode","runningGetServerDataActivity","getPageChunk","mod","getServerData","serverDataResults","all","props","pageContext","serverDataHeaders","headersFromConfig","getRoutePathFromPage","MUST_REVALIDATE_HEADERS","header","key","value","headers","headerKey","headerValue","Object","entries","searchString","maybeQueryString","map","k","v","encodeURIComponent","join","serverDataStatus","status","getPath","data","matchPath","renderPageData","activity","sliceOverrides","slices","slicesFromBundler","GATSBY_SLICES","Map","set","slicesUsedByTemplatesFromBundler","GATSBY_SLICES_BY_TEMPLATE","slicesUsedByTemplates","constructPageDataString","staticQueryHashes","JSON","stringify","parse","readStaticQuery","staticQueryHash","filePath","__dirname","rawSQContext","fs","readFile","readSliceData","sliceName","rawSliceData","renderHTML","pageData","wrapperActivity","sliceData","readSliceDataActivity","values","slicesMap","readStaticQueryContextActivity","staticQueryContext","Set","singleSliceData","add","contextsToMerge","Array","from","assign","renderHTMLActivity","pagePath","htmlComponentRenderer","webpackCompilationHash","WEBPACK_COMPILATION_HASH","assets","inlinePageData","html","replace","GATSBY_SLICES_SCRIPT","stateWithPages","pages","GATSBY_PAGES","findPageByPath"],"sources":["../../../src/utils/page-ssr-module/entry.ts"],"sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../engines-fs-provider\"\n\n// just types - those should not be bundled\nimport type { GraphQLEngine } from \"../../schema/graphql-engine/entry\"\nimport type { IExecutionResult } from \"../../query/types\"\nimport type {\n  IGatsbyPage,\n  IGatsbySlice,\n  IGatsbyState,\n  IHeader,\n} from \"../../redux/types\"\nimport { IGraphQLTelemetryRecord } from \"../../schema/type-definitions\"\nimport type { IScriptsAndStyles } from \"../client-assets-for-template\"\nimport type { IPageDataWithQueryResult, ISliceData } from \"../page-data\"\nimport type { Request } from \"express\"\nimport type { Span, SpanContext } from \"opentracing\"\n\n// actual imports\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport {\n  constructPageDataString,\n  getPagePathFromPageDataPath,\n} from \"../page-data-helpers\"\n// @ts-ignore render-page import will become valid later on (it's marked as external)\nimport htmlComponentRenderer, { getPageChunk } from \"./routes/render-page\"\nimport { getServerData, IServerData } from \"../get-server-data\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { initTracer } from \"../tracer\"\nimport { getCodeFrame } from \"../../query/graphql-errors-codeframe\"\nimport { ICollectedSlice } from \"../babel/find-slices\"\nimport { createHeadersMatcher } from \"../adapter/create-headers\"\nimport { MUST_REVALIDATE_HEADERS } from \"../adapter/constants\"\nimport { getRoutePathFromPage } from \"../adapter/get-route-path\"\nimport { findPageByPath } from \"../find-page-by-path\"\n\nexport interface ITemplateDetails {\n  query: string\n  staticQueryHashes: Array<string>\n  assets: IScriptsAndStyles\n}\n\nexport type EnginePage = Pick<\n  IGatsbyPage,\n  | \"componentChunkName\"\n  | \"componentPath\"\n  | \"context\"\n  | \"matchPath\"\n  | \"mode\"\n  | \"path\"\n  | \"slices\"\n>\n\nexport interface ISSRData {\n  results: IExecutionResult\n  page: EnginePage\n  templateDetails: ITemplateDetails\n  potentialPagePath: string\n  /**\n   * This is no longer really just serverDataHeaders, as we add headers\n   * from user defined in gatsby-config\n   */\n  serverDataHeaders?: Record<string, string>\n  serverDataStatus?: number\n  searchString: string\n}\n\n// just letting TypeScript know about injected data\n// with DefinePlugin\ndeclare global {\n  const INLINED_TEMPLATE_TO_DETAILS: Record<string, ITemplateDetails>\n  const INLINED_HEADERS_CONFIG: Array<IHeader> | undefined\n  const WEBPACK_COMPILATION_HASH: string\n  const GATSBY_SLICES_SCRIPT: string\n  const GATSBY_PAGES: Array<[string, EnginePage]>\n  const PATH_PREFIX: string\n}\n\nconst tracerReadyPromise = initTracer(\n  process.env.GATSBY_OPEN_TRACING_CONFIG_FILE ?? ``\n)\n\ntype MaybePhantomActivity =\n  | ReturnType<typeof reporter.phantomActivity>\n  | undefined\n\nconst createHeaders = createHeadersMatcher(INLINED_HEADERS_CONFIG, PATH_PREFIX)\n\ninterface IGetDataBaseArgs {\n  pathName: string\n  req?: Partial<Pick<Request, \"query\" | \"method\" | \"url\" | \"headers\">>\n  spanContext?: Span | SpanContext\n  telemetryResolverTimings?: Array<IGraphQLTelemetryRecord>\n}\n\ninterface IGetDataEagerEngineArgs extends IGetDataBaseArgs {\n  graphqlEngine: GraphQLEngine\n}\n\ninterface IGetDataLazyEngineArgs extends IGetDataBaseArgs {\n  getGraphqlEngine: () => Promise<GraphQLEngine>\n}\n\ntype IGetDataArgs = IGetDataEagerEngineArgs | IGetDataLazyEngineArgs\n\nfunction isEagerGraphqlEngine(\n  arg: IGetDataArgs\n): arg is IGetDataEagerEngineArgs {\n  return typeof (arg as IGetDataEagerEngineArgs).graphqlEngine !== `undefined`\n}\n\nexport async function getData(arg: IGetDataArgs): Promise<ISSRData> {\n  const getGraphqlEngine = isEagerGraphqlEngine(arg)\n    ? (): Promise<GraphQLEngine> => Promise.resolve(arg.graphqlEngine)\n    : arg.getGraphqlEngine\n\n  const { pathName, req, spanContext, telemetryResolverTimings } = arg\n  await tracerReadyPromise\n\n  let getDataWrapperActivity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      getDataWrapperActivity = reporter.phantomActivity(`Running getData`, {\n        parentSpan: spanContext,\n      })\n      getDataWrapperActivity.start()\n    }\n\n    let page: EnginePage\n    let templateDetails: ITemplateDetails\n    let potentialPagePath: string\n    let findMetaActivity: MaybePhantomActivity\n    try {\n      if (getDataWrapperActivity) {\n        findMetaActivity = reporter.phantomActivity(\n          `Finding details about page and template`,\n          {\n            parentSpan: getDataWrapperActivity.span,\n          }\n        )\n        findMetaActivity.start()\n      }\n      potentialPagePath = getPagePathFromPageDataPath(pathName) || pathName\n\n      // 1. Find a page for pathname\n      const maybePage = findEnginePageByPath(potentialPagePath)\n\n      if (!maybePage) {\n        // page not found, nothing to run query for\n        throw new Error(`Page for \"${pathName}\" not found`)\n      }\n\n      page = maybePage\n\n      // 2. Lookup query used for a page (template)\n      templateDetails = INLINED_TEMPLATE_TO_DETAILS[page.componentChunkName]\n      if (!templateDetails) {\n        throw new Error(\n          `Page template details for \"${page.componentChunkName}\" not found`\n        )\n      }\n    } finally {\n      if (findMetaActivity) {\n        findMetaActivity.end()\n      }\n    }\n\n    const executionPromises: Array<Promise<any>> = []\n\n    // 3. Execute query\n    // query-runner handles case when query is not there - so maybe we should consider using that somehow\n    let results: IExecutionResult = {}\n    let serverData: IServerData | undefined\n    if (templateDetails.query) {\n      let runningQueryActivity: MaybePhantomActivity\n      if (getDataWrapperActivity) {\n        runningQueryActivity = reporter.phantomActivity(`Running page query`, {\n          parentSpan: getDataWrapperActivity.span,\n        })\n        runningQueryActivity.start()\n      }\n      executionPromises.push(\n        getGraphqlEngine().then(graphqlEngine =>\n          graphqlEngine\n            .runQuery(\n              templateDetails.query,\n              {\n                ...page,\n                ...page.context,\n              },\n              {\n                queryName: page.path,\n                componentPath: page.componentPath,\n                parentSpan: runningQueryActivity?.span,\n                forceGraphqlTracing: !!runningQueryActivity,\n                telemetryResolverTimings,\n              }\n            )\n            .then(queryResults => {\n              if (queryResults.errors && queryResults.errors.length > 0) {\n                const e = queryResults.errors[0]\n                const codeFrame = getCodeFrame(\n                  templateDetails.query,\n                  e.locations && e.locations[0].line,\n                  e.locations && e.locations[0].column\n                )\n\n                const queryRunningError = new Error(\n                  e.message + `\\n\\n` + codeFrame\n                )\n                queryRunningError.stack = e.stack\n                throw queryRunningError\n              } else {\n                results = queryResults\n              }\n            })\n            .finally(() => {\n              if (runningQueryActivity) {\n                runningQueryActivity.end()\n              }\n            })\n        )\n      )\n    }\n\n    // 4. (if SSR) run getServerData\n    if (page.mode === `SSR`) {\n      let runningGetServerDataActivity: MaybePhantomActivity\n      if (getDataWrapperActivity) {\n        runningGetServerDataActivity = reporter.phantomActivity(\n          `Running getServerData`,\n          {\n            parentSpan: getDataWrapperActivity.span,\n          }\n        )\n        runningGetServerDataActivity.start()\n      }\n      executionPromises.push(\n        getPageChunk(page)\n          .then(mod => getServerData(req, page, potentialPagePath, mod))\n          .then(serverDataResults => {\n            serverData = serverDataResults\n          })\n          .finally(() => {\n            if (runningGetServerDataActivity) {\n              runningGetServerDataActivity.end()\n            }\n          })\n      )\n    }\n\n    await Promise.all(executionPromises)\n\n    if (serverData) {\n      results.serverData = serverData.props\n    }\n    results.pageContext = page.context\n\n    const serverDataHeaders = {}\n\n    // get headers from defaults and config\n    const headersFromConfig = createHeaders(\n      getRoutePathFromPage(page),\n      MUST_REVALIDATE_HEADERS\n    )\n    // convert headers array to object\n    for (const header of headersFromConfig) {\n      serverDataHeaders[header.key] = header.value\n    }\n\n    if (serverData?.headers) {\n      // add headers from getServerData to object (which will overwrite headers from config if overlapping)\n      for (const [headerKey, headerValue] of Object.entries(\n        serverData.headers\n      )) {\n        serverDataHeaders[headerKey] = headerValue\n      }\n    }\n\n    let searchString = ``\n\n    if (req?.query) {\n      const maybeQueryString = Object.entries(req.query)\n        .map(\n          ([k, v]) =>\n            // Preserve QueryString encoding\n            `${encodeURIComponent(k)}=${encodeURIComponent(v as string)}`\n        )\n        .join(`&`)\n      if (maybeQueryString) {\n        searchString = `?${maybeQueryString}`\n      }\n    }\n\n    return {\n      results,\n      page,\n      templateDetails,\n      potentialPagePath,\n      serverDataHeaders,\n      serverDataStatus: serverData?.status,\n      searchString,\n    }\n  } finally {\n    if (getDataWrapperActivity) {\n      getDataWrapperActivity.end()\n    }\n  }\n}\n\nfunction getPath(data: ISSRData): string {\n  return (\n    (data.page.mode !== `SSG` && data.page.matchPath\n      ? data.potentialPagePath\n      : data.page.path) + (data.page.mode === `SSR` ? data.searchString : ``)\n  )\n}\n\nexport async function renderPageData({\n  data,\n  spanContext,\n}: {\n  data: ISSRData\n  spanContext?: Span | SpanContext\n}): Promise<IPageDataWithQueryResult> {\n  await tracerReadyPromise\n\n  let activity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      activity = reporter.phantomActivity(`Rendering page-data`, {\n        parentSpan: spanContext,\n      })\n      activity.start()\n    }\n\n    const componentPath = data.page.componentPath\n    const sliceOverrides = data.page.slices\n\n    // @ts-ignore GATSBY_SLICES is being \"inlined\" by bundler\n    const slicesFromBundler = GATSBY_SLICES as {\n      [key: string]: IGatsbySlice\n    }\n    const slices: IGatsbyState[\"slices\"] = new Map()\n    for (const [key, value] of Object.entries(slicesFromBundler)) {\n      slices.set(key, value)\n    }\n\n    const slicesUsedByTemplatesFromBundler =\n      // @ts-ignore GATSBY_SLICES_BY_TEMPLATE is being \"inlined\" by bundler\n      GATSBY_SLICES_BY_TEMPLATE as {\n        [key: string]: { [key: string]: ICollectedSlice }\n      }\n    const slicesUsedByTemplates: IGatsbyState[\"slicesByTemplate\"] = new Map()\n    for (const [key, value] of Object.entries(\n      slicesUsedByTemplatesFromBundler\n    )) {\n      slicesUsedByTemplates.set(key, value)\n    }\n\n    // TODO: optimize this to only pass name for slices, as it's only used for validation\n\n    const results = await constructPageDataString(\n      {\n        componentChunkName: data.page.componentChunkName,\n        path: getPath(data),\n        matchPath: data.page.matchPath,\n        staticQueryHashes: data.templateDetails.staticQueryHashes,\n        componentPath,\n        slices: sliceOverrides,\n      },\n      JSON.stringify(data.results),\n      slicesUsedByTemplates,\n      slices\n    )\n\n    return JSON.parse(results)\n  } finally {\n    if (activity) {\n      activity.end()\n    }\n  }\n}\nconst readStaticQuery = async (\n  staticQueryHash: string\n): Promise<Record<string, { data: unknown }>> => {\n  const filePath = path.join(__dirname, `sq`, `${staticQueryHash}.json`)\n  const rawSQContext = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawSQContext)\n}\n\nconst readSliceData = async (sliceName: string): Promise<ISliceData> => {\n  const filePath = path.join(__dirname, `slice-data`, `${sliceName}.json`)\n\n  const rawSliceData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawSliceData)\n}\n\nexport async function renderHTML({\n  data,\n  pageData,\n  spanContext,\n}: {\n  data: ISSRData\n  pageData?: IPageDataWithQueryResult\n  spanContext?: Span | SpanContext\n}): Promise<string> {\n  await tracerReadyPromise\n\n  let wrapperActivity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      wrapperActivity = reporter.phantomActivity(`Rendering HTML`, {\n        parentSpan: spanContext,\n      })\n      wrapperActivity.start()\n    }\n\n    if (!pageData) {\n      pageData = await renderPageData({\n        data,\n        spanContext: wrapperActivity?.span,\n      })\n    }\n\n    const sliceData: Record<string, ISliceData> = {}\n    if (_CFLAGS_.GATSBY_MAJOR === `5` && process.env.GATSBY_SLICES) {\n      let readSliceDataActivity: MaybePhantomActivity\n      try {\n        if (wrapperActivity) {\n          readSliceDataActivity = reporter.phantomActivity(\n            `Preparing slice-data`,\n            {\n              parentSpan: wrapperActivity.span,\n            }\n          )\n          readSliceDataActivity.start()\n        }\n        for (const sliceName of Object.values(pageData.slicesMap)) {\n          sliceData[sliceName] = await readSliceData(sliceName)\n        }\n      } finally {\n        if (readSliceDataActivity) {\n          readSliceDataActivity.end()\n        }\n      }\n    }\n\n    let readStaticQueryContextActivity: MaybePhantomActivity\n    let staticQueryContext: Record<string, { data: unknown }>\n    try {\n      if (wrapperActivity) {\n        readStaticQueryContextActivity = reporter.phantomActivity(\n          `Preparing StaticQueries context`,\n          {\n            parentSpan: wrapperActivity.span,\n          }\n        )\n        readStaticQueryContextActivity.start()\n      }\n\n      const staticQueryHashes = new Set<string>(pageData.staticQueryHashes)\n      for (const singleSliceData of Object.values(sliceData)) {\n        for (const staticQueryHash of singleSliceData.staticQueryHashes) {\n          staticQueryHashes.add(staticQueryHash)\n        }\n      }\n\n      const contextsToMerge = await Promise.all(\n        Array.from(staticQueryHashes).map(async staticQueryHash => {\n          return {\n            [staticQueryHash]: await readStaticQuery(staticQueryHash),\n          }\n        })\n      )\n\n      staticQueryContext = Object.assign({}, ...contextsToMerge)\n    } finally {\n      if (readStaticQueryContextActivity) {\n        readStaticQueryContextActivity.end()\n      }\n    }\n\n    let renderHTMLActivity: MaybePhantomActivity\n    try {\n      if (wrapperActivity) {\n        renderHTMLActivity = reporter.phantomActivity(\n          `Actually rendering HTML`,\n          {\n            parentSpan: wrapperActivity.span,\n          }\n        )\n        renderHTMLActivity.start()\n      }\n\n      const pagePath = getPath(data)\n      const results = await htmlComponentRenderer({\n        pagePath,\n        pageData,\n        staticQueryContext,\n        webpackCompilationHash: WEBPACK_COMPILATION_HASH,\n        ...data.templateDetails.assets,\n        inlinePageData: data.page.mode === `SSR` && data.results.serverData,\n        sliceData,\n      })\n\n      return results.html.replace(\n        `<slice-start id=\"_gatsby-scripts-1\"></slice-start><slice-end id=\"_gatsby-scripts-1\"></slice-end>`,\n        GATSBY_SLICES_SCRIPT\n      )\n    } finally {\n      if (renderHTMLActivity) {\n        renderHTMLActivity.end()\n      }\n    }\n  } finally {\n    if (wrapperActivity) {\n      wrapperActivity.end()\n    }\n  }\n}\n\nconst stateWithPages = {\n  pages: new Map(GATSBY_PAGES),\n} as unknown as IGatsbyState\n\nexport function findEnginePageByPath(pathName: string): EnginePage | undefined {\n  return findPageByPath(stateWithPages, pathName, false)\n}\n"],"mappings":"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"}